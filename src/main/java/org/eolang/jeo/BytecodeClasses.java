/*
 * SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
 * SPDX-License-Identifier: MIT
 */
package org.eolang.jeo;

import com.jcabi.log.Logger;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.SimpleVerifier;
import org.objectweb.asm.util.CheckClassAdapter;

/**
 * Bytecode classes verifier.
 *
 * <p>This class knows how to verify generated bytecode. It performs comprehensive
 * verification of bytecode files using ASM's analysis framework. It requires all
 * the classes to be loaded into the current classloader. See {@link PluginStartup#init()}
 * for details on how all generated classes are loaded.</p>
 * @since 0.6.0
 */
final class BytecodeClasses {

    /**
     * Input directory where all the generated class files are placed.
     */
    private final Path input;

    /**
     * Constructor.
     * @param input Input directory where all the generated class files are placed.
     */
    BytecodeClasses(final Path input) {
        this.input = input;
    }

    /**
     * All the class files.
     * @return Stream of paths to class files
     */
    Stream<Path> all() {
        try {
            return this.classes().stream();
        } catch (final IOException exception) {
            throw new IllegalStateException(
                String.format(
                    "Can't read '%s' directory with classes",
                    this.input
                ),
                exception
            );
        }
    }

    /**
     * Verify bytecode in the folder.
     */
    void verify() {
        this.all().forEach(BytecodeClasses::verify);
    }

    /**
     * Find all bytecode files.
     * @return Collection of bytecode files
     * @throws IOException If some I/O problem arises
     */
    private Collection<Path> classes() throws IOException {
        if (Objects.isNull(this.input)) {
            throw new IllegalStateException(
                "The classes directory is not set, jeo-maven-plugin does not know where to look for classes."
            );
        }
        if (!Files.exists(this.input)) {
            throw new IllegalStateException(
                String.format(
                    "The classes directory '%s' does not exist, jeo-maven-plugin does not know where to look for classes.",
                    this.input
                )
            );
        }
        try (Stream<Path> walk = Files.walk(this.input)) {
            return walk
                .filter(Files::isRegularFile)
                .filter(path -> path.toString().endsWith(".class"))
                .collect(Collectors.toList());
        }
    }

    /**
     * Read bytes of the class file.
     * @param clazz Path to the class file to read
     * @return Bytes of the class file
     */
    private static byte[] read(final Path clazz) {
        try {
            return Files.readAllBytes(clazz);
        } catch (final IOException exception) {
            throw new IllegalStateException(
                String.format("Can't read bytecode from the file '%s'", clazz),
                exception
            );
        }
    }

    /**
     * Verify the bytecode of the class file.
     * @param clazz Path to the class file to verify
     */
    private static void verify(final Path clazz) {
        final byte[] bytes = BytecodeClasses.read(clazz);
        try {
            BytecodeClasses.verify(bytes);
        } catch (final IllegalArgumentException exception) {
            throw new IllegalArgumentException(
                String.format("Invalid bytecode of class '%s'", clazz), exception
            );
        }
    }

    /**
     * Verify the generated bytecode.
     * @param bytes Bytecode bytes to verify
     */
    private static void verify(final byte[] bytes) {
        final ClassNode clazz = new ClassNode();
        new ClassReader(bytes)
            .accept(new CheckClassAdapter(clazz, false), ClassReader.SKIP_DEBUG);
        final Optional<Type> syper = Optional.ofNullable(clazz.superName)
            .map(Type::getObjectType);
        final List<Type> interfaces = clazz.interfaces.stream().map(Type::getObjectType)
            .collect(Collectors.toList());
        for (final MethodNode method : clazz.methods) {
            try {
                final SimpleVerifier verifier =
                    new SimpleVerifier(
                        Type.getObjectType(clazz.name),
                        syper.orElse(null),
                        interfaces,
                        (clazz.access & Opcodes.ACC_INTERFACE) != 0
                    );
                verifier.setClassLoader(Thread.currentThread().getContextClassLoader());
                new Analyzer<>(verifier).analyze(clazz.name, method);
            } catch (final ClassFormatError | AnalyzerException exception) {
                throw new IllegalStateException(
                    String.format(
                        "Bytecode verification failed for the class '%s' and method '%s'",
                        clazz.name,
                        method.name
                    ),
                    exception
                );
            }
        }
        Logger.info(
            BytecodeClasses.class,
            String.format("Bytecode verification passed for the class '%s'", clazz.name)
        );
    }
}
